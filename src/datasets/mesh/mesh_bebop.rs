//!
//! This code was generated by a tool.
//!
//!
//!   bebopc version:
//!       2.3.0
//!
//!
//!   bebopc source:
//!       https://github.com/RainwayApp/bebop
//!
//!
//! Changes to this file may cause incorrect behavior and will be lost if
//! the code is regenerated.
//!

#![allow(warnings)]

use ::std::io::Write as _;
use ::core::convert::TryInto as _;
use ::bebop::FixedSized as _;

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Vector3 {
    pub x: f32,
    pub y: f32,
    pub z: f32,
}

impl ::bebop::FixedSized for Vector3 {}

impl<'raw> ::bebop::SubRecord<'raw> for Vector3 {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.x._serialize_chained(dest)? +
            self.y._serialize_chained(dest)? +
            self.z._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            x: v0,
            y: v1,
            z: v2,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Vector3 {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Triangle {
    pub v0: Vector3,
    pub v1: Vector3,
    pub v2: Vector3,
    pub normal: Vector3,
}

impl ::bebop::FixedSized for Triangle {}

impl<'raw> ::bebop::SubRecord<'raw> for Triangle {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.v0._serialize_chained(dest)? +
            self.v1._serialize_chained(dest)? +
            self.v2._serialize_chained(dest)? +
            self.normal._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <Vector3>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <Vector3>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <Vector3>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <Vector3>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            v0: v0,
            v1: v1,
            v2: v2,
            normal: v3,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Triangle {}

#[derive(Clone, Debug, PartialEq)]
pub struct Mesh<'raw> {
    pub triangles: ::bebop::SliceWrapper<'raw, Triangle>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Mesh<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <::bebop::SliceWrapper<'raw, Triangle>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.triangles.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.triangles._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <::bebop::SliceWrapper<'raw, Triangle>>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            triangles: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Mesh<'raw> {}


//!
//! This code was generated by a tool.
//!
//!
//!   bebopc version:
//!       2.3.0
//!
//!
//!   bebopc source:
//!       https://github.com/RainwayApp/bebop
//!
//!
//! Changes to this file may cause incorrect behavior and will be lost if
//! the code is regenerated.
//!

#![allow(warnings)]

use ::std::io::Write as _;
use ::core::convert::TryInto as _;
use ::bebop::FixedSized as _;

#[repr(u32)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum GameType {
    Survival = 0,
    Creative = 1,
    Adventure = 2,
    Spectator = 3,
}

impl ::core::convert::TryFrom<u32> for GameType {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u32) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(GameType::Survival),
            1 => Ok(GameType::Creative),
            2 => Ok(GameType::Adventure),
            3 => Ok(GameType::Spectator),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(d)),
        }
    }
}

impl ::core::convert::From<GameType> for u32 {
    fn from(value: GameType) -> Self {
        match value {
            GameType::Survival => 0,
            GameType::Creative => 1,
            GameType::Adventure => 2,
            GameType::Spectator => 3,
        }
    }
}

impl<'raw> ::bebop::SubRecord<'raw> for GameType {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::ENUM_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::bebop::ENUM_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize { ::bebop::ENUM_SIZE }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u32::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u32::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for GameType {
    const SERIALIZED_SIZE: usize = ::bebop::ENUM_SIZE;
}


#[derive(Clone, Debug, PartialEq)]
pub struct Item<'raw> {
    pub count: i32,
    pub slot: u32,
    pub id: &'raw str,
}

impl<'raw> ::bebop::SubRecord<'raw> for Item<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <i32>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.count.serialized_size() +
        self.slot.serialized_size() +
        self.id.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.count._serialize_chained(dest)? +
            self.slot._serialize_chained(dest)? +
            self.id._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <i32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <&'raw str>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            count: v0,
            slot: v1,
            id: v2,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Item<'raw> {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Abilities {
    pub walk_speed: f32,
    pub fly_speed: f32,
    pub may_fly: bool,
    pub flying: bool,
    pub invulnerable: bool,
    pub may_build: bool,
    pub instabuild: bool,
}

impl ::bebop::FixedSized for Abilities {}

impl<'raw> ::bebop::SubRecord<'raw> for Abilities {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.walk_speed._serialize_chained(dest)? +
            self.fly_speed._serialize_chained(dest)? +
            self.may_fly._serialize_chained(dest)? +
            self.flying._serialize_chained(dest)? +
            self.invulnerable._serialize_chained(dest)? +
            self.may_build._serialize_chained(dest)? +
            self.instabuild._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            walk_speed: v0,
            fly_speed: v1,
            may_fly: v2,
            flying: v3,
            invulnerable: v4,
            may_build: v5,
            instabuild: v6,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Abilities {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Vector3D {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

impl ::bebop::FixedSized for Vector3D {}

impl<'raw> ::bebop::SubRecord<'raw> for Vector3D {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.x._serialize_chained(dest)? +
            self.y._serialize_chained(dest)? +
            self.z._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <f64>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <f64>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <f64>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            x: v0,
            y: v1,
            z: v2,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Vector3D {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Vector2F {
    pub x: f32,
    pub y: f32,
}

impl ::bebop::FixedSized for Vector2F {}

impl<'raw> ::bebop::SubRecord<'raw> for Vector2F {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.x._serialize_chained(dest)? +
            self.y._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            x: v0,
            y: v1,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Vector2F {}

#[derive(Clone, Debug, PartialEq, Copy)]
#[repr(packed)]
pub struct Uuid {
    pub x0: u32,
    pub x1: u32,
    pub x2: u32,
    pub x3: u32,
}

impl ::bebop::FixedSized for Uuid {}

impl<'raw> ::bebop::SubRecord<'raw> for Uuid {
    const MIN_SERIALIZED_SIZE: usize = Self::SERIALIZED_SIZE;
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(Self::SERIALIZED_SIZE);

    #[inline]
    fn serialized_size(&self) -> usize {
        Self::SERIALIZED_SIZE
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.x0._serialize_chained(dest)? +
            self.x1._serialize_chained(dest)? +
            self.x2._serialize_chained(dest)? +
            self.x3._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            x0: v0,
            x1: v1,
            x2: v2,
            x3: v3,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Uuid {}

#[derive(Clone, Debug, PartialEq)]
pub struct Entity<'raw> {
    pub id: &'raw str,
    pub pos: Vector3d,
    pub motion: Vector3d,
    pub rotation: Vector2f,
    pub fall_distance: f32,
    pub fire: u32,
    pub air: u32,
    pub on_ground: bool,
    pub no_gravity: bool,
    pub invulnerable: bool,
    pub portal_cooldown: i32,
    pub uuid: Uuid,
    pub custom_name: &'raw str,
    pub custom_name_visible: bool,
    pub silent: bool,
    pub glowing: bool,
}

impl<'raw> ::bebop::SubRecord<'raw> for Entity<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <Vector3d>::MIN_SERIALIZED_SIZE +
        <Vector3d>::MIN_SERIALIZED_SIZE +
        <Vector2f>::MIN_SERIALIZED_SIZE +
        <f32>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <i32>::MIN_SERIALIZED_SIZE +
        <Uuid>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.id.serialized_size() +
        self.pos.serialized_size() +
        self.motion.serialized_size() +
        self.rotation.serialized_size() +
        self.fall_distance.serialized_size() +
        self.fire.serialized_size() +
        self.air.serialized_size() +
        self.on_ground.serialized_size() +
        self.no_gravity.serialized_size() +
        self.invulnerable.serialized_size() +
        self.portal_cooldown.serialized_size() +
        self.uuid.serialized_size() +
        self.custom_name.serialized_size() +
        self.custom_name_visible.serialized_size() +
        self.silent.serialized_size() +
        self.glowing.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.id._serialize_chained(dest)? +
            self.pos._serialize_chained(dest)? +
            self.motion._serialize_chained(dest)? +
            self.rotation._serialize_chained(dest)? +
            self.fall_distance._serialize_chained(dest)? +
            self.fire._serialize_chained(dest)? +
            self.air._serialize_chained(dest)? +
            self.on_ground._serialize_chained(dest)? +
            self.no_gravity._serialize_chained(dest)? +
            self.invulnerable._serialize_chained(dest)? +
            self.portal_cooldown._serialize_chained(dest)? +
            self.uuid._serialize_chained(dest)? +
            self.custom_name._serialize_chained(dest)? +
            self.custom_name_visible._serialize_chained(dest)? +
            self.silent._serialize_chained(dest)? +
            self.glowing._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <&'raw str>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <Vector3d>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <Vector3d>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <Vector2f>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v7) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v8) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v9) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v10) = <i32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v11) = <Uuid>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v12) = <&'raw str>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v13) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v14) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v15) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            id: v0,
            pos: v1,
            motion: v2,
            rotation: v3,
            fall_distance: v4,
            fire: v5,
            air: v6,
            on_ground: v7,
            no_gravity: v8,
            invulnerable: v9,
            portal_cooldown: v10,
            uuid: v11,
            custom_name: v12,
            custom_name_visible: v13,
            silent: v14,
            glowing: v15,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Entity<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct RecipeBook<'raw> {
    pub recipes: ::std::vec::Vec<&'raw str>,
    pub to_be_displayed: ::std::vec::Vec<&'raw str>,
    pub is_filtering_craftable: bool,
    pub is_gui_open: bool,
    pub is_furnace_filtering_craftable: bool,
    pub is_furnace_gui_open: bool,
    pub is_blasting_furnace_filtering_craftable: bool,
    pub is_blasting_furnace_gui_open: bool,
    pub is_smoker_filtering_craftable: bool,
    pub is_smoker_gui_open: bool,
}

impl<'raw> ::bebop::SubRecord<'raw> for RecipeBook<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <::std::vec::Vec<&'raw str>>::MIN_SERIALIZED_SIZE +
        <::std::vec::Vec<&'raw str>>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.recipes.serialized_size() +
        self.to_be_displayed.serialized_size() +
        self.is_filtering_craftable.serialized_size() +
        self.is_gui_open.serialized_size() +
        self.is_furnace_filtering_craftable.serialized_size() +
        self.is_furnace_gui_open.serialized_size() +
        self.is_blasting_furnace_filtering_craftable.serialized_size() +
        self.is_blasting_furnace_gui_open.serialized_size() +
        self.is_smoker_filtering_craftable.serialized_size() +
        self.is_smoker_gui_open.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.recipes._serialize_chained(dest)? +
            self.to_be_displayed._serialize_chained(dest)? +
            self.is_filtering_craftable._serialize_chained(dest)? +
            self.is_gui_open._serialize_chained(dest)? +
            self.is_furnace_filtering_craftable._serialize_chained(dest)? +
            self.is_furnace_gui_open._serialize_chained(dest)? +
            self.is_blasting_furnace_filtering_craftable._serialize_chained(dest)? +
            self.is_blasting_furnace_gui_open._serialize_chained(dest)? +
            self.is_smoker_filtering_craftable._serialize_chained(dest)? +
            self.is_smoker_gui_open._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <::std::vec::Vec<&'raw str>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <::std::vec::Vec<&'raw str>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v7) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v8) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v9) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            recipes: v0,
            to_be_displayed: v1,
            is_filtering_craftable: v2,
            is_gui_open: v3,
            is_furnace_filtering_craftable: v4,
            is_furnace_gui_open: v5,
            is_blasting_furnace_filtering_craftable: v6,
            is_blasting_furnace_gui_open: v7,
            is_smoker_filtering_craftable: v8,
            is_smoker_gui_open: v9,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for RecipeBook<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Vehicle<'raw> {
    pub uuid: Uuid,
    pub entity: Entity<'raw>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Vehicle<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <Uuid>::MIN_SERIALIZED_SIZE +
        <Entity<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.uuid.serialized_size() +
        self.entity.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.uuid._serialize_chained(dest)? +
            self.entity._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <Uuid>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <Entity<'raw>>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            uuid: v0,
            entity: v1,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Vehicle<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Player<'raw> {
    pub game_type: GameType,
    pub previous_game_type: GameType,
    pub sore: u64,
    pub dimension: &'raw str,
    pub selected_item_slot: u32,
    pub selected_item: Item<'raw>,
    pub spawn_dimension: &'raw str,
    pub spawn_x: i64,
    pub spawn_y: i64,
    pub spawn_z: i64,
    pub spawn_forced: bool,
    pub sleep_timer: u32,
    pub food_exhaustion_level: f32,
    pub food_saturation_level: f32,
    pub food_tick_timer: u32,
    pub xp_level: u32,
    pub xp_p: f32,
    pub xp_total: i32,
    pub xp_seed: i32,
    pub inventory: ::std::vec::Vec<Item<'raw>>,
    pub ender_items: ::std::vec::Vec<Item<'raw>>,
    pub abilities: Abilities,
    pub entered_nether_position: Vector3d,
    pub root_vehicle: Vehicle<'raw>,
    pub shoulder_entity_left: Entity<'raw>,
    pub shoulder_entity_right: Entity<'raw>,
    pub seen_credits: bool,
    pub recipe_book: RecipeBook<'raw>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Player<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <GameType>::MIN_SERIALIZED_SIZE +
        <GameType>::MIN_SERIALIZED_SIZE +
        <u64>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <Item<'raw>>::MIN_SERIALIZED_SIZE +
        <&'raw str>::MIN_SERIALIZED_SIZE +
        <i64>::MIN_SERIALIZED_SIZE +
        <i64>::MIN_SERIALIZED_SIZE +
        <i64>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <f32>::MIN_SERIALIZED_SIZE +
        <f32>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <u32>::MIN_SERIALIZED_SIZE +
        <f32>::MIN_SERIALIZED_SIZE +
        <i32>::MIN_SERIALIZED_SIZE +
        <i32>::MIN_SERIALIZED_SIZE +
        <::std::vec::Vec<Item<'raw>>>::MIN_SERIALIZED_SIZE +
        <::std::vec::Vec<Item<'raw>>>::MIN_SERIALIZED_SIZE +
        <Abilities>::MIN_SERIALIZED_SIZE +
        <Vector3d>::MIN_SERIALIZED_SIZE +
        <Vehicle<'raw>>::MIN_SERIALIZED_SIZE +
        <Entity<'raw>>::MIN_SERIALIZED_SIZE +
        <Entity<'raw>>::MIN_SERIALIZED_SIZE +
        <bool>::MIN_SERIALIZED_SIZE +
        <RecipeBook<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.game_type.serialized_size() +
        self.previous_game_type.serialized_size() +
        self.sore.serialized_size() +
        self.dimension.serialized_size() +
        self.selected_item_slot.serialized_size() +
        self.selected_item.serialized_size() +
        self.spawn_dimension.serialized_size() +
        self.spawn_x.serialized_size() +
        self.spawn_y.serialized_size() +
        self.spawn_z.serialized_size() +
        self.spawn_forced.serialized_size() +
        self.sleep_timer.serialized_size() +
        self.food_exhaustion_level.serialized_size() +
        self.food_saturation_level.serialized_size() +
        self.food_tick_timer.serialized_size() +
        self.xp_level.serialized_size() +
        self.xp_p.serialized_size() +
        self.xp_total.serialized_size() +
        self.xp_seed.serialized_size() +
        self.inventory.serialized_size() +
        self.ender_items.serialized_size() +
        self.abilities.serialized_size() +
        self.entered_nether_position.serialized_size() +
        self.root_vehicle.serialized_size() +
        self.shoulder_entity_left.serialized_size() +
        self.shoulder_entity_right.serialized_size() +
        self.seen_credits.serialized_size() +
        self.recipe_book.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.game_type._serialize_chained(dest)? +
            self.previous_game_type._serialize_chained(dest)? +
            self.sore._serialize_chained(dest)? +
            self.dimension._serialize_chained(dest)? +
            self.selected_item_slot._serialize_chained(dest)? +
            self.selected_item._serialize_chained(dest)? +
            self.spawn_dimension._serialize_chained(dest)? +
            self.spawn_x._serialize_chained(dest)? +
            self.spawn_y._serialize_chained(dest)? +
            self.spawn_z._serialize_chained(dest)? +
            self.spawn_forced._serialize_chained(dest)? +
            self.sleep_timer._serialize_chained(dest)? +
            self.food_exhaustion_level._serialize_chained(dest)? +
            self.food_saturation_level._serialize_chained(dest)? +
            self.food_tick_timer._serialize_chained(dest)? +
            self.xp_level._serialize_chained(dest)? +
            self.xp_p._serialize_chained(dest)? +
            self.xp_total._serialize_chained(dest)? +
            self.xp_seed._serialize_chained(dest)? +
            self.inventory._serialize_chained(dest)? +
            self.ender_items._serialize_chained(dest)? +
            self.abilities._serialize_chained(dest)? +
            self.entered_nether_position._serialize_chained(dest)? +
            self.root_vehicle._serialize_chained(dest)? +
            self.shoulder_entity_left._serialize_chained(dest)? +
            self.shoulder_entity_right._serialize_chained(dest)? +
            self.seen_credits._serialize_chained(dest)? +
            self.recipe_book._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <GameType>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = <GameType>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = <u64>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v3) = <&'raw str>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v4) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v5) = <Item<'raw>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v6) = <&'raw str>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v7) = <i64>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v8) = <i64>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v9) = <i64>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v10) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v11) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v12) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v13) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v14) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v15) = <u32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v16) = <f32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v17) = <i32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v18) = <i32>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v19) = <::std::vec::Vec<Item<'raw>>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v20) = <::std::vec::Vec<Item<'raw>>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v21) = <Abilities>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v22) = <Vector3d>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v23) = <Vehicle<'raw>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v24) = <Entity<'raw>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v25) = <Entity<'raw>>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v26) = <bool>::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v27) = <RecipeBook<'raw>>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            game_type: v0,
            previous_game_type: v1,
            sore: v2,
            dimension: v3,
            selected_item_slot: v4,
            selected_item: v5,
            spawn_dimension: v6,
            spawn_x: v7,
            spawn_y: v8,
            spawn_z: v9,
            spawn_forced: v10,
            sleep_timer: v11,
            food_exhaustion_level: v12,
            food_saturation_level: v13,
            food_tick_timer: v14,
            xp_level: v15,
            xp_p: v16,
            xp_total: v17,
            xp_seed: v18,
            inventory: v19,
            ender_items: v20,
            abilities: v21,
            entered_nether_position: v22,
            root_vehicle: v23,
            shoulder_entity_left: v24,
            shoulder_entity_right: v25,
            seen_credits: v26,
            recipe_book: v27,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Player<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Players<'raw> {
    pub players_: ::std::vec::Vec<Player<'raw>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Players<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <::std::vec::Vec<Player<'raw>>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.players_.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(
            self.players_._serialize_chained(dest)?
        )
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = <::std::vec::Vec<Player<'raw>>>::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self {
            players_: v0,
        }))
    }
}

impl<'raw> ::bebop::Record<'raw> for Players<'raw> {}

